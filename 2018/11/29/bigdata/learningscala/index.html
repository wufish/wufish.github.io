<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>学习记录-scala | wufish的博客</title><meta name="keywords" content="bigdata, scala"><meta name="author" content="wufish,wuzhijunw@163.com"><meta name="copyright" content="wufish"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="scala 学习笔记"><meta property="og:type" content="article"><meta property="og:title" content="学习记录-scala"><meta property="og:url" content="https://wufish.github.io/2018/11/29/bigdata/learningscala/index.html"><meta property="og:site_name" content="wufish的博客"><meta property="og:description" content="scala 学习笔记"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://wufish.github.io/images/default.jpeg"><meta property="article:published_time" content="2018-11-28T16:00:00.000Z"><meta property="article:modified_time" content="2020-10-05T12:02:20.097Z"><meta property="article:author" content="wufish"><meta property="article:tag" content="bigdata"><meta property="article:tag" content="scala"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://wufish.github.io/images/default.jpeg"><link rel="shortcut icon" href="/images/avatar.png"><link rel="canonical" href="https://wufish.github.io/2018/11/29/bigdata/learningscala/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="yandex-verification" content="{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: wufish","link":"链接: ","source":"来源: wufish的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE={isPost:!0,isHome:!1,isHighlightShrink:!1,isSidebar:!0,postUpdate:"2020-10-05 20:02:20"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/images/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">25</div></a></div></div><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">23</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于我</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#scala%E5%85%A5%E9%97%A8"><span class="toc-number">1.</span> <span class="toc-text">scala入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96%E6%95%B0%E7%BB%84Array"><span class="toc-number">1.1.</span> <span class="toc-text">类型参数化数组Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">1.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tuple"><span class="toc-number">1.3.</span> <span class="toc-text">Tuple</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map-%E5%92%8CSet"><span class="toc-number">1.4.</span> <span class="toc-text">Map 和Set</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E3%80%81%E5%AD%97%E6%AE%B5%E5%92%8C%E6%96%B9%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">类、字段和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F%E5%92%8C%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.1.</span> <span class="toc-text">字面量和操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%BB%BA%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">内建结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85"><span class="toc-number">2.3.</span> <span class="toc-text">函数和闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">组合与继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scala%E7%9A%84%E5%B1%82%E7%BA%A7"><span class="toc-number">4.</span> <span class="toc-text">scala的层级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E8%B4%A8"><span class="toc-number">5.</span> <span class="toc-text">特质</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">包和引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B7%E6%9C%AC%E7%B1%BB%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">5.2.</span> <span class="toc-text">样本类和模式匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8"><span class="toc-number">5.3.</span> <span class="toc-text">列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">5.4.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E7%8A%B6%E6%80%81%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.</span> <span class="toc-text">有状态的对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E5%8C%96"><span class="toc-number">5.6.</span> <span class="toc-text">类型参数化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%88%90%E5%91%98"><span class="toc-number">6.</span> <span class="toc-text">抽象成员</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%92%8C%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">隐式转换和隐式参数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List-1"><span class="toc-number">8.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E5%8F%96%E5%99%A8"><span class="toc-number">9.</span> <span class="toc-text">抽取器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">10.</span> <span class="toc-text">注解</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89"><span class="toc-number">11.</span> <span class="toc-text">对象相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Actor"><span class="toc-number">12.</span> <span class="toc-text">Actor</span></a></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image:url(/images/default.jpeg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wufish的博客</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于我</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">学习记录-scala</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-11-28T16:00:00.000Z" title="发表于 2018-11-29 00:00:00">2018-11-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-10-05T12:02:20.097Z" title="更新于 2020-10-05 20:02:20">2020-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/bigdata/">bigdata</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/bigdata/scala/">scala</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2018/11/29/bigdata/learningscala/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>[TOC]</p><a id="more"></a><h1 id="scala入门"><a href="#scala入门" class="headerlink" title="scala入门"></a>scala入门</h1><h2 id="类型参数化数组Array"><a href="#类型参数化数组Array" class="headerlink" title="类型参数化数组Array"></a>类型参数化数组Array</h2><ul><li>参数化：创建实例的同时完成对他的设置。使用值（字面值初始化）和类型（）使对象参数化</li><li>Array 引用不可变，内容可变（同样的地址和大小，不同的值）</li><li>scala没有操作符重载，都是方法。</li><li>数组也只是类的实例，传参调用apply方法。=赋值也是调用update（index，value）方法</li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul><li>方法没有副作用（返回值）是函数式编程的重要理念。（方法间的耦合度降低；可以根据类型错误判断隐含的逻辑错误）</li><li>list 引用（对象本身）不可变，元素也不可变</li><li><code>:::</code>是list的叠加，两个list元素组合，<code>::</code>（发音cons）只是将新的元素组合到现有列表的最前端，然后返回新列表。（:是右结合操作符）</li><li>List 不支持append，可以使用ListBuilder或者 ::，然后reverse</li></ul><h2 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><ul><li>可以包含不同类型的元素，和List一样也是不可变的</li><li>使用 <code>x._1</code> <code>x._2</code> 访问元素</li></ul><h2 id="Map-和Set"><a href="#Map-和Set" class="headerlink" title="Map 和Set"></a>Map 和Set</h2><ul><li>分为可变和不可变对象 <code>scala.collection.immutale.Set scala.collection.mutable.Set</code></li><li><code>+</code> 方法传入新元素。不可变对象则是返回一个新的对象</li><li>可以通过工厂方法构造对象。<code>val hashset = new HashSet(“123”，“456”)</code></li></ul><h1 id="类、字段和方法"><a href="#类、字段和方法" class="headerlink" title="类、字段和方法"></a>类、字段和方法</h1><ul><li>scala 成员默认是public</li><li>scala 方法参数都是val，不能重新赋值</li><li>去掉方法体前面的等号，那么方法的结果类型必定是Unit</li><li>一行包含多条语句一定要加分号；只包含一条可以不加</li><li>scala 不能定义静态成员，而是用单例对象取代。单例对象如果和某个类同名，就称为这个类的伴生对象，且必须定义在一个文件里，可以相互访问其私有成员。</li><li>单例对象不用new，所以不带参数，而类可以。单例对象在第一次被访问的时候才会被初始化，每个单例对象都视为虚构类的实例。</li></ul><h2 id="字面量和操作符"><a href="#字面量和操作符" class="headerlink" title="字面量和操作符"></a>字面量和操作符</h2><ul><li>java的基本类型和操作符在scala中是同样的意思。</li><li>字面量（literal），就是直接写在代码里的常量值。’&lt;标识符&gt; 符号字面量：<code>scala.Symbol</code>，符号字面量除了能显示名字外，什么都不能做；</li><li>任何方法都可以是操作符，看如何使用。中缀（infix）后缀（suffix）前缀。前缀操作符和中缀操作符都是 值类型对象调用方法的简写。</li><li><code>==</code> 先判断左侧的对象是否为null，如果不是再调用左操作数的equals方法。 java中== 对于原始类型比较的是值是否相等，对引用类型比较的是JVM中是否指向同一个对象。scala用 eq 和 ne 比较引用是否指向同一个对象。 如果方法结束于： ，就自右向左分组，否则自左向右分组。</li></ul><h2 id="内建结构"><a href="#内建结构" class="headerlink" title="内建结构"></a>内建结构</h2><ul><li>函数式对象：不具有任何可变状态的对象的类。</li><li>不可变对象，可变对象。不可变对象更易理清头绪；可以很自由地传递不可变对象；不会因为并发破坏内部状态；可以让哈希表键值更安全；节省审查作用域的时间和工作。缺点：需要复制很大的对象表。</li><li>scala 编译器把 类内部 任何既不是字段也不是方法的定义编译至主构造器中。</li><li>主构造器的先决条件（保证对象的有效性）：require方法 <code>require(d != 0)</code>, false 抛出 IllegalArgumentException 异常</li><li>scala 对象只能访问自身的值（不能访问类参数：主构造器的参数），可以通过添加字段赋值的方式使用类参数。</li><li>每个scala的构造器调用终将结束于对主构造器的调用。只有主构造器可以调用超类的构造器</li><li>字母数字标识符： scala遵循驼峰标识符。不能将<code>$</code>作为标识符。scala常量也使用驼峰风格并且首字母大写。 操作符标识符： 混合标识符：是用来支持属性的 字面量标识符：用反引号包括的任意字符串。可以吧运行时环境认可的任意字符串放在反引号之间当做标识符。（区分已经存在的标识符）</li><li>隐式转换 起作用需要定义在 作用范围之内。</li><li>对var 再赋值本身也是<code>unit</code>，</li><li>for 可以使用花括号代替小括号包裹发生器和过滤器，花括号可以省略小括号时必须加的分号</li><li>for(子句) yield{循环体} ，for表达式结束时，将返回包含了所有产生值的集合对象</li><li>通常避免finally子句，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def g(): Int &#x3D; try &#123;1&#125; return &#123;2&#125;</span><br><span class="line">&#x2F;&#x2F;返回值是1，</span><br><span class="line">def g(): Int &#x3D; try &#123;return 1&#125; return &#123;return 2&#125;</span><br><span class="line">&#x2F;&#x2F; 返回值是2.</span><br></pre></td></tr></table></figure><ul><li><code>match case</code> 可以匹配任意类型</li><li>不再使用break和continue，用if和布尔值替换</li><li>java中不允许在内部范围创建和外部范围变量同名的变量。scala中内部变量会遮蔽同名的外部变量</li></ul><h2 id="函数和闭包"><a href="#函数和闭包" class="headerlink" title="函数和闭包"></a>函数和闭包</h2><ul><li><p>函数式编程的设计原则：把程序解构成若干小的函数，每块实现一个定义完备的任务，但是容易污染程序的命名空间（造成函数名重复）。可以使用本地函数，将多个函数定义在别的函数之内。</p></li><li><p>对象的成员函数称为方法。</p></li><li><p>函数字面量被编译进类，并在运行期实例化为函数值。函数的字面量和值得区别在于 函数字面量存在于源码，而函数值作为对象存在于运行期。 函数字面量： <code>(x: Int) =&gt; x+1</code> 函数值： <code>var increase = (x: Int) =&gt; x + 1</code> 函数字面量也可以包含多条语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var increase &#x3D; (x: Int) &#x3D;&gt; &#123;</span><br><span class="line">println(&quot;We&quot;)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数字面量 可以去除参数类型，也可以使用占位符_ (下划线)，多个下划线指代多个参数79</p></li><li><p>scala的函数是头等函数。不仅可以定义和调用函数，还可以把他们写成匿名字面量，并把它们作为值传递。</p></li><li><p>部分应用函数（Partial Applied Function，和偏函数PartialFunction不同），提供函数所需的参数，而不是全部提供</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sum(a:Int,b:Int,c:Int) &#x3D; a + b + c</span><br><span class="line">def p_sum &#x3D; sum(1, _:Int, _:Int)        &#x2F;&#x2F;部分应用函数</span><br></pre></td></tr></table></figure><p>使用柯里化后，该函数柯里化后单独对第二个参数进行了更详细的功能定义，丰富了函数的功能。</p></li><li><p>函数字面量在运行时创建的函数值（对象）被称为闭包。通过捕获自由变量的绑定，从而对函数字面量执行的关闭行动。 闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。 闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val addMore &#x3D; (x: Int) &#x3D;&gt; x+more    &#x2F;&#x2F;more是自由变量</span><br></pre></td></tr></table></figure></li></ul><p>任何包含自由变量的函数字面量称为开放项，在运行期创建的函数值必须补货对自由变量more的绑定。 闭包对捕获变量做出的改变在闭包之外也是可见的（也就是在闭包内可以改变自由变量的值）</p><ul><li><p>使用的实例是那个在闭包被创建的时候活跃的。</p></li><li><p>重复参数 <code>args: String</code></p></li><li><p>尾递归：最后一个操作调用自己的函数。 scala编译器检测到尾递归就用新值更新函数参数，然后把它替换成一个回到函数开头的跳转。 尾递归不会为每个调用创造新的堆栈结构，多有调用将在一个结构内执行。（scala对尾递归调用做了优化） 尾递归优化局限：必须是直接递归调用使其返回同一个函数；</p></li></ul><p>最后一个调用不能是一个函数值（不能将递归调用赋值给参数）</p><ul><li><p>总结：scala函数包括：方法、本地函数、函数字面量、函数值；函数调用包括：普通调用、部分应用函数、带重复参数。如果有可能函数调用应被实现为优化的尾调用。 控制抽象</p></li><li><p>Scala是函数式语言,所以函数是头等值。同时它也是面向对象语言,所以所有的值都是对象。</p></li><li><p>使用头等值和闭包减少代码重复</p></li><li><p>scala支持头等值：（即函数可以作为参数传递给函数） 闭包：query是自由变量，可以省略fileMatching的query参数，因为会自动捕获自由变量query。 不使用闭包：</p></li><li><p>柯里化 currying ：应用于多个参数列表 def curriedSum(x: Int)(y: Int) = x + y val onePlus = curriedSum(1) <em>val twoPlus = curriedSum(2)</em></p></li><li><p>编写新的控制结构：创建带函数做参数的方法。当代码中多个地方有重复的控制模式时。就应该考虑将它实现为一个新的控制结构。</p></li><li><p>在只传入一个参数时，使用花括号代替小括号包围参数列表，目的是让客户端程序员写出包围在花括号内的函数字面量。（如果多参数列表，则需要先柯里化）</p></li><li><p>传名参数（by-name parameter） 属性里省略空的参数 () =&gt; Boolean 中 () 被省略了，但仅在参数中被允许。</p></li></ul><p>Scala的解释器在解析函数参数(function arguments)时有两种方式：先计算参数表达式的值(reduce the arguments)，再应用到函数内部；或者是将未计算的参数表达式直接应用到函数内部。前者叫做传值调用（call-by-value），后者叫做传名调用（call-by-name）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object Add &#123;</span><br><span class="line">def addByName(a: Int, b: &#x3D;&gt; Int) &#x3D; a + b &#x2F;&#x2F;传名调用</span><br><span class="line">def addByValue(a: Int, b: Int) &#x3D; a + b&#x2F;&#x2F;传值调用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传值调用在进入函数体之前就对参数表达式进行了计算，这避免了函数内部多次使用参数时重复计算其值，在一定程度上提高了效率。但是传名调用的一个优势在于，如果参数在函数体内部没有被使用到，那么它就不用计算参数表达式的值了。在这种情况下，传名调用的效率会高一点。</p><ul><li>总结：使用函数提取通用的控制模式</li></ul><h1 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h1><ul><li>库设计：简单对象？连符？通用组合？</li><li>抽象类：abstract说明类可能有未被实现的成员，不能实例化一个抽象类。scala中一个方法只要没有实现它就是抽象的。 声明（declaration），定义（definition）</li><li>惯例：只要方法中没有参数并且方法仅能通过读取所包含对象的属性去访问可变状态（特指方法不能改变可变状态）就用无参数方法。 调用的方法超出其调用者对象的属性时，推荐仍然写上括号</li></ul><blockquote><p>定义省去括号：没有参数且没有副作用</p></blockquote><blockquote><p>使用省去括号：仅仅访问属性，没有操作</p></blockquote><ul><li><p>scala中的类隐式地扩展自<code>scala.AnyRef</code></p></li><li><p>scala 字段和方法统一访问原则； 字段和方法属于相同的命名空间，字段可以重写无参方法，Scala里禁止在同一个类里用同样的名称定义字段和方法</p></li><li><p>Java 命名空间：字段、方法、类型、包；scala：值（字段、方法、包和单例对象）、类型（类和特质名）</p><blockquote><p>Scala里包共享了与字段和方法相同的命名空间的原因是为了让你能除了仅仅引用类型名以及单例对象的字段和方法之外，还能直接引用包。这同样是你在Java中无法做到的</p></blockquote></li><li><p>参数化字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class ArrayElement( &#x2F;&#x2F;请注意，小括号</span><br><span class="line">val contents: Array[String] )</span><br><span class="line">extends Element</span><br></pre></td></tr></table></figure><p>为了拥有一个可以从类外部访问的字段，可能添加如private，protected，override</p></li><li><p>超类构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class LineElement(s: String) extends ArrayElement(Array(s)) &#123;</span><br><span class="line">override def width &#x3D; s.length</span><br><span class="line">override def height &#x3D; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多态(父类引用指向子类对象)和动态绑定（变量和表达式上的方法调用是动态绑定）</p></li></ul><blockquote><p>什么是多态？<br><br>概念：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用基类的引用指向子类的对象。</p></blockquote><blockquote><p>为什么要用多态呢？<br><br>原因：我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了—-代码重用。而多态除了代码的复用性外，还可以解决项目中紧偶合的问题,提高程序的可扩展性.。耦合度讲的是模块模块之间，代码代码之间的关联度，通过对系统的分析把他分解成一个一个子模块，子模块提供稳定的接口，达到降低系统耦合度的的目的，模块模块之间尽量使用模块接口访问，而不是随意引用其他模块的成员变量。</p></blockquote><blockquote><p>多态有什么好处</p></blockquote><blockquote><ol><li>应用程序不必为每一个派生类编写功能调用，只需要对抽象基类进行处理即可。大大提高程序的可复用性。//继承</li><li>派生类的功能可以被基类的方法或引用变量所调用，这叫向后兼容，可以提高可扩充性和可维护性。 //多态的真正作用</li></ol></blockquote><ul><li><p><code>++</code> 连接两个数组，Scala里的数组继承自类<code>scala.Seq</code></p></li><li><p>工厂对象：将对象的创建集中化并且隐藏对象实际代表的细节。一方面，可以让用户更容易理解库，暴露更少的细节；另一方面可以不破话客户代码的前提下改变库的实现。</p></li></ul><h1 id="scala的层级"><a href="#scala的层级" class="headerlink" title="scala的层级"></a>scala的层级</h1><ul><li><p>Nothing是所有其他类的子类，Any是所有类的超类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Any定义的方法</span><br><span class="line">final def &#x3D;&#x3D;(that: Any): Boolean</span><br><span class="line">final def !&#x3D;(that: Any): Boolean</span><br><span class="line">def equals(that: Any): Boolean</span><br><span class="line">def hashCode: Int</span><br><span class="line">def toString: String</span><br></pre></td></tr></table></figure></li><li><p>Any的两个子类：AnyVal和AnyRef。</p><ul><li>AnyVal是scala里每个内建值类的父类（Byte，Short，Char，Int，Long，Float，Double，Boolean和Unit(相当于<code>()</code>)，对应java的基本类型，他们的值对应java基本类型的值，他们的实例都写成字面量，==不能用new 创建这些类的实例。== -</li><li>AnyRef,是所有引用类的基类（类似java.lang.Object）。</li></ul></li><li><p>scala 里相等<code>==</code>被设计为对类型表达透明。引用类型视为继承自Object的equals方法的别名</p></li><li><p><code>eq</code> 引用相等，<code>ne</code> 引用不相等</p></li><li><p>scala.Null 是null引用对象的类型，不兼容值类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val i: Int &#x3D; null</span><br><span class="line">&#x2F;&#x2F;error:type mismatch,不能把值赋值给数值类型变量</span><br></pre></td></tr></table></figure></li><li><p>Nothing，任何其他类型的子类型，没有这个类型的任何值</p></li></ul><h1 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h1><ul><li><p>trait，代码复用的基础单元；超类是AnyRef；特质同样也是类型，</p></li><li><p>特质不能像类传递参数那样给主构造器传参；特质中super调用是动态绑定的。</p></li><li><p>胖接口：根据类已有的方法添加方法，丰富一个瘦接口</p></li><li><p>Ordered特质 定义&lt; &gt; &lt;= &gt;=，来比较排序的类</p></li><li><p>特质用法：瘦接口变成胖接口；可堆叠的改变（会按照混入的特质的顺序执行特质中的方法）</p></li><li><p>特质可以定义超类，这样特质就只能混入扩展了该超类的类中；可以在声明为抽象的方法中调用super，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">abstrat class IntQueue&#123;</span><br><span class="line">    def get(): Int</span><br><span class="line">    def put(x: Int)</span><br><span class="line">&#125;</span><br><span class="line">trait Incrementing extents IntQueue&#123;</span><br><span class="line">    abstract override def put(x: Int) &#123;super.put(x + 1)&#125;</span><br><span class="line">&#125;</span><br><span class="line">trait Filtering extends IntQueue&#123;</span><br><span class="line">    abstract override def put(x: Int)&#123;</span><br><span class="line">        if(x &gt;&#x3D; 0) super.put(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BasicIntQueue extends IntQUeue&#123;</span><br><span class="line">    private val buf &#x3D; new ArrayBuffer[Int]</span><br><span class="line">    def get() &#x3D; buf.remove(0)</span><br><span class="line">    def put(x: Int) &#123;buf +&#x3D; x&#125;</span><br><span class="line">&#125;</span><br><span class="line">val queue &#x3D; (new BasicIntQueue with Filtering with Incrementing)</span><br><span class="line">queue.put(-2);queue.put(-1);queue.put(0),queue.put(1)</span><br><span class="line">&#x2F;&#x2F;第一个-2先加1，但是还是负数，直接过滤，后面的元素加1后大于0，放入队列中</span><br><span class="line">queue.get()&#x2F;&#x2F;0</span><br><span class="line">queue.get()&#x2F;&#x2F;1</span><br><span class="line">queue.get()&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure><p>因此可以以不同的组合和次序混入特质实现灵活的功能（取决于scala 特质中 super方法的动态绑定）</p></li><li><p>可堆叠：scala 特质以线性的次序放在一起，通过线性化解释super</p></li><li><p>如果行为不会被重用，那么就作为具体类，具体类没有可重用的行为</p></li><li><p>如果要在多个不想改观的类中重用，就做成特质，只有特质可以混入到不同的类层级中。</p></li><li><p>如果希望从java代码中继承它，就是用抽象类。</p></li><li><p>如果希望编译后发布，外部组织能写一些继承自它的类，倾向于使用抽象类。当特质获得或失去成员，所有继承自它的类就算没有改变也要重新编译，如果不是继承，那么使用特质就没有问题。</p></li></ul><h2 id="包和引用"><a href="#包和引用" class="headerlink" title="包和引用"></a>包和引用</h2><ul><li>scala的包是嵌套的，不需要从包层级的根开始</li><li><code>_root_</code>访问顶层的包</li><li>scala的按需引用使用<code>_</code></li><li>scala的灵活引用<ul><li>可以出现在任何地方</li><li>可以指的是（单例或正统的）对象及包</li><li>可以重命名或者隐藏一些被引用的成员<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Apple 重命名为McIntosh</span><br><span class="line">import Fruits.&#123;Apple&#x3D;&gt;McIntosh, Orange&#125;</span><br><span class="line">&#x2F;&#x2F;除了Pear外都被引用</span><br><span class="line">import Fruits.&#123;Pear &#x3D;&gt; _, _&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>隐式引用，后面的引用会覆盖前面的引用</li><li>java允许外部类访问其内部类的私有成员，而scala不允许</li><li>scala中protected 只允许类及其子类访问，而java允许同一个包访问</li><li>scala的访问修饰符可以通过限定词强调。private[x],表示直到x的私有，x代表包、类或者单例对象</li><li>private[this] 只能在包含了定义的同一个对象中被访问，成为对象私有</li><li>scala 中没有静态成员，但可以在单例对象中定义来实现</li><li>类和伴生对象之间可以相互访问所有权限额成员</li><li>assert 断言 ensuring 检查</li></ul><h2 id="样本类和模式匹配"><a href="#样本类和模式匹配" class="headerlink" title="样本类和模式匹配"></a>样本类和模式匹配</h2><ul><li>样本类：希望用来做模式匹配的每个类前加一个case</li><li>样本类可以供便捷设定<ul><li>添加与类名一致的工厂方法（创建对象是省略new）</li><li>样本类参数列表中的所有参数隐式获得了val前缀</li><li>编译器为类添加了toString、hashCode、equals实现</li></ul></li><li>scala 里的==始终直接转到equals</li><li>match<ul><li>始终以值作为结果</li><li>scala的备选表达式永远不会掉到下一个case</li><li>如果没有模式匹配，MatchError异常会被抛出</li></ul></li><li>match匹配类型：通配符模式<code>_</code>、常量模式、变量模式（任意对象）、构造器模式（样本类，可以匹配对象内部的任意深度：首先检查对象是该名称的样本类的成员，然后检查对象的构造器参数是否符合额外提供的模式的）、序列模式、元组模式、类型模式、变量绑定（<code>e @ 对象</code>，把变量e设置成匹配的对象）</li><li>小写字母开始的简单名被当做是模式变量，所有其他的引用被认为是常量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val pi &#x3D; Math.Pi</span><br><span class="line">E match &#123;</span><br><span class="line">    case pi &#x3D;&gt; &quot;Pi &#x3D; &quot; + pi</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;pi 被当做模式变量赋值E</span><br><span class="line">&#x2F;&#x2F;如果常量是对象的字段，在其之上加上限定符前缀，或者使用反引号包住变量名</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;类型匹配</span><br><span class="line">def generalSize(x: Any) &#x3D; match &#123;</span><br><span class="line">    case s: String &#x3D;&gt; s.length</span><br><span class="line">    case m: Map[_, _] &#x3D;&gt; m.size</span><br><span class="line">    case _ &#x3D;&gt; 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>x.isInstanceOf[String], x.asInstanceOf[String]</li><li>scala使用了泛型的擦除模式，类型参数信息没有保留到运行期，运行期没有办法判断给定的对象创建时的参数类型（数组除外，数组的元素类型与数组值保存在一起，可以做模式匹配）</li><li>scala的模式是线性的：模式变量仅允许在模式中出现一次<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;模式守卫 接在模式之后，开始于if，守卫可以任意引用模式中变量的布尔表达式</span><br><span class="line">def simplifyAdd(e: Exp) &#x3D; e match &#123;</span><br><span class="line">    case BinOP(&quot;+&quot;, x, y) if x &#x3D;&#x3D; y &#x3D;&gt; BinOp(&quot;*&quot;, x, Number(2))</span><br><span class="line">    case _ &#x3D;&gt; e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>封闭类<code>sealed</code>：除了类定义躲在的文件之外不能再添加任何新的子类。（不需要担心模式匹配中出现不知道的类）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;添加@unchecked注解，对于随后的模式的穷举性检查将被抑制掉</span><br><span class="line">def describe(e: Expr): String &#x3D; (e: @unchecked) match&#123;</span><br><span class="line">    case Number(_) &#x3D;&gt; &quot;a number&quot;</span><br><span class="line">    case Var(_) &#x3D;&gt; &quot;a variable&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Option，可以是Some(x)；也可以是None，代表缺失的值。</li><li>模式匹配使用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;元组拆分</span><br><span class="line">val (string, number) &#x3D; (&quot;11&quot;, 112)</span><br><span class="line">&#x2F;&#x2F;样本类的精确构造,解构</span><br><span class="line">val BinOp(p[, left, right) &#x3D; new BinOp(&quot;*&quot;, Number(5), Number(1))</span><br><span class="line">&#x2F;&#x2F;用作偏函数的样本序列，每个样本都是函数的一个入口点，参数也被模式所特化</span><br><span class="line">val withDefault: Option[Int] &#x3D;&gt; Int &#x3D; &#123;</span><br><span class="line">    case Some(x) &#x3D;&gt; x</span><br><span class="line">    case None &#x3D;&gt; 0</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;for</span><br><span class="line">for((x, y) &lt;- capitals)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>列表元素是不可变的，具有递归解构</li><li>协变：如果S是T的子类型，List[S]也是List[T]的子类型</li><li><code>::</code>，发音cons，右结合。</li><li><code>:::</code>，连接两个列表,xs:::ys所用的时间与第一个参数xs的长度成正比</li><li>length</li><li>head 第一个元素 tail 除第一个以外 last 最后一个 init 除最后一个以外 reverse drop 除前n个以外 take 前n个 splitAt 指定位置拆分 indices 所有索引值组成的列表</li><li>zip 两个列表组成对偶列表，取两个中最小长度 toSting mkString addString 构建好的字符串添加到StringBuffer</li><li>toArray copyToArray(arr, start)把列表元素复制到目标数组的一段连续空间 elements 枚举器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;插入排序</span><br><span class="line">def isort(xs: List[Int]): List[Int] &#x3D; &#123;</span><br><span class="line">  if (xs.isEmpty) Nil</span><br><span class="line">  else insert(xs.head, isort(xs.tail))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def insert(x: Int, xs: List[Int]): List[Int] &#x3D; &#123;</span><br><span class="line">  if (xs.isEmpty || x &lt;&#x3D; xs.head) x :: xs</span><br><span class="line">  else xs.head :: insert(x, xs.tail)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;归并排序,复杂度nlog(n)</span><br><span class="line">def msort[T](less: (T, T) &#x3D;&gt; Boolean)</span><br><span class="line">            (xs: List[T]): List[T] &#x3D; &#123;</span><br><span class="line">  def merge(xs: List[T], ys: List[T]): List[T] &#x3D; &#123;</span><br><span class="line">    (xs, ys) match &#123;</span><br><span class="line">      case (Nil, _) &#x3D;&gt; ys</span><br><span class="line">      case (_, Nil) &#x3D;&gt; xs</span><br><span class="line">      case (x :: xs1, y :: ys1) &#x3D;&gt;</span><br><span class="line">        if (less(x, y)) x :: merge(xs1, ys)</span><br><span class="line">        else y :: merge(xs, ys1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val n &#x3D; xs.length &#x2F; 2</span><br><span class="line">  if (n &#x3D;&#x3D; 0) xs</span><br><span class="line">  else &#123;</span><br><span class="line">    val (ys, zs) &#x3D; xs splitAt n</span><br><span class="line">    merge(msort(less)(ys), msort(less)(zs))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>列表映射 map flatMap foreach</li><li>列表过滤 filter partition 和filter类似，不过返回的是列表对：一个为真的数据，一个为假的数据 find 返回第一个满足的元素 takeWhile 返回最长的满足条件的前缀 dropWhile 移除最长的满足条件的前缀 span 把 takeWhile和dropWhile组合成一个操作，避免二次访问（就像splitAt 组合了 take和drop一样）</li><li>forall exists sort</li><li>折叠操作<code>/:</code> (z /: xs)(op) <code>\:</code> (xs \: z)(op)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;List反转</span><br><span class="line">def reverseLeft[T](xs: List[T]) &#x3D; </span><br><span class="line">    (List[T]() &#x2F;: xs) &#123; (ys, y) &#x3D;&gt; y :: ys&#125;</span><br></pre></td></tr></table></figure>对象方法</li><li>List.range(from, until, step)</li><li>List.make(5, ‘a’) 创建重复元素</li><li>List.unzip List.flatten List.concat</li><li>List.map2 List.forall2 List.exists2</li><li>scala的类型推断是基于流的，如果需要推断多态方法类型参数时，类型推断器就只会参考第一个参数列表中所有的值参数类型，不会参考之后的其他参数</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>特质Iterable指代的是可以被枚举的类型，而特质Iterator是用来执行枚举操作的机制。</li><li>Seq，不可变，有序的：List、Array、Queue、Stack</li><li>ListBuffer 支持常量时间的添加和前缀操作<code>+=</code> 添加元素， <code>+:</code> 前缀添加，使用toList获得List</li><li>ArrayBuffer</li><li>Queue enqueue(List(1,2)) 添加元素 dequeue 不可变Queue，返回移除的头部元素和剩余的队列，可变Queue返回移除的元素</li><li>Stack pop push</li><li>String 会隐式转换为RichString</li></ul><table><thead><tr><th>操作</th><th>行为</th></tr></thead><tbody><tr><td>val nums = Set(1,2,3)</td><td>创建不可变Set</td></tr><tr><td>nums + 5</td><td>添加元素</td></tr><tr><td>nums - 3</td><td>删除元素</td></tr><tr><td>nums ++ List(5,6)</td><td>添加多个元素</td></tr><tr><td>nums – List(1,2)</td><td>删除多个元素</td></tr><tr><td>nums ** Set(1,2,3)</td><td>交集</td></tr><tr><td>nums.size</td><td>数量</td></tr><tr><td>nums.contains(3)</td><td>是否包含</td></tr><tr><td>import scala.collection.mutable</td><td>可变集合</td></tr><tr><td>val words = mutable.Set.empty[String]</td><td></td></tr><tr><td>words += “the”</td><td>添加</td></tr><tr><td>words -= “the”</td><td>删除</td></tr><tr><td>words ++= List(“dd”,”ss”,”aa”)</td><td>添加多个</td></tr><tr><td>words –= List(“rr”)</td><td>删除多个</td></tr><tr><td>words.clear</td><td></td></tr></tbody></table><ul><li>Map</li></ul><table><thead><tr><th>操作</th><th>行为</th></tr></thead><tbody><tr><td>val nums = Map(“i”-&gt;1,”ii”-&gt;2)</td><td>创建不可变Map</td></tr><tr><td>nums + (“vi”-&gt;6)</td><td></td></tr><tr><td>num - “ii”</td><td></td></tr><tr><td>nums ++ List(“iii”-&gt;3, “v”-&gt;4)</td><td></td></tr><tr><td>nums – List(“i”,”ii”)</td><td></td></tr><tr><td>nums.size</td><td></td></tr><tr><td>nums.contains(“ii”)</td><td></td></tr><tr><td>nums(“ii”)</td><td></td></tr><tr><td>nums.keys</td><td></td></tr><tr><td>nums.keySet</td><td></td></tr><tr><td>nums.values</td><td></td></tr><tr><td>nums.isEmpty</td><td></td></tr><tr><td>import scala.collection.mutable</td><td></td></tr><tr><td>val words = mutable.Map.empty[String, Int]</td><td></td></tr><tr><td>words += (“one”-&gt;1)</td><td></td></tr><tr><td>words -= “one”</td><td></td></tr><tr><td>words ++= List(“one”-&gt;1,”two”-&gt;)</td><td></td></tr><tr><td>words –= List(“one”, “two”)</td><td></td></tr></tbody></table><ul><li>SortedSet SortedMap, 通过TreeSet和TreeMap保存数据</li><li>混入SynchronizedMap，重写default方法，线程安全</li></ul><h2 id="有状态的对象"><a href="#有状态的对象" class="headerlink" title="有状态的对象"></a>有状态的对象</h2><ul><li>scala中每个非私有的var 都隐含定义了getter(变量x表示)和setter(x_表示)，并且保留了原本var变量的可见性</li><li>val celsius: Float = _ //_根据类型初始化字段</li></ul><h2 id="类型参数化"><a href="#类型参数化" class="headerlink" title="类型参数化"></a>类型参数化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">trait Queue[T] &#123;</span><br><span class="line">  def head: T</span><br><span class="line"></span><br><span class="line">  def tail: Queue[T]</span><br><span class="line"></span><br><span class="line">  def append(x: T): Queue[T]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Queue &#123;</span><br><span class="line">  def apply[T](xs: T*): Queue[T] &#x3D;</span><br><span class="line">    new QueueImpl[T](xs.toList, Nil)</span><br><span class="line"></span><br><span class="line">  private class QueueImpl[T](</span><br><span class="line">    private val leading: List[T],</span><br><span class="line">    private val trailing: List[T]</span><br><span class="line">  ) extends Queue[T] &#123;</span><br><span class="line">    def mirror &#x3D;</span><br><span class="line">      if (leading.isEmpty)</span><br><span class="line">        new QueueImpl(trailing.reverse, Nil)</span><br><span class="line">      else</span><br><span class="line">        this</span><br><span class="line"></span><br><span class="line">    def head: T &#x3D; mirror.leading.head</span><br><span class="line"></span><br><span class="line">    def tail: QueueImpl[T] &#x3D; &#123;</span><br><span class="line">      val q &#x3D; mirror</span><br><span class="line">      new QueueImpl(q.leading.tail, q.trailing)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    def append(x: T) &#x3D;</span><br><span class="line">      new QueueImpl(leading, x :: trailing)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Queue 称为类型构造器</p><ul><li><p>协变：S是类型T的子类型，Queue[S]也是Queue[T] 的子类型。scala默认是非协变的，在正常的类型参数前加上+号表明这个参数的子类型化是协变的（Queue[T]是Queue[S]的子类型），-号表示逆协变。这种方式称为参数的变化型。</p></li><li><p>在纯函数式中，许多类型都是自然协变的，但引入可变数据就会出问题，有的事情Any可以做，Sting不可以做</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val c1 &#x3D; new Cell[String](&quot;abc&quot;)</span><br><span class="line">val c2: Cell[Any] &#x3D; c1</span><br><span class="line">c2.set(1)</span><br><span class="line">val s: String &#x3D; c1.get</span><br><span class="line">&#x2F;&#x2F;协变类型的Cell编译器报错</span><br></pre></td></tr></table></figure></li><li><p>scala不认为数组是协变的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val a1 &#x3D; Array(&quot;abc&quot;)</span><br><span class="line">val a2: Array[Any] &#x3D; a1</span><br><span class="line">&#x2F;&#x2F;报错，type mismatch，而在java中可以</span><br><span class="line">&#x2F;&#x2F;可以通过以下方式解决</span><br><span class="line">val a2: Array[Object] &#x3D; a1.asInstanceOf[Array[Object]]</span><br></pre></td></tr></table></figure></li><li><p>只要泛型的参数类型被当做方法参数的类型，那么包含他的类或者特质就有可能不能与这个类型参数一起协变（比如setter方法带有字段类型T的参数，类型T不能是协变的）</p></li><li><p><code>U &gt;: T</code> 表示 T为U的下界，即U必须是T的超类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Queue[+T] (private val leading: List[T], private val trailing: List[T]) &#123;</span><br><span class="line">    def append[U &gt;: T](x: U) &#x3D;</span><br><span class="line">        new Queue[U](leading, x :: trailing)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 下界和协变组合使用</span><br></pre></td></tr></table></figure></li><li><p>里氏替换原则：如果能在需要类型U的值得地方替换成类型T的值，那么类型T是类型U的子类型的假设就是安全的</p></li><li><p>函数在参数上是逆变的，在返回值上则是协变的。通常而言，对于某个对象消费的值适用逆变，而对于它产出的值适用协变。如果一个对象同时消费和产出某值，则类型应该保持不变。这通常适用于可变数据结构，比如标准库中的Array、ArrayBuffer、ListBuffer等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trait Function1[-S, +T] &#123;</span><br><span class="line">    def apply(x: S): T</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型参数化用来编写泛型类和特质；变化型注解，定义了参数化类型的继承关系。这些语法可以实现信息隐藏技术，也是编写库程序的基础</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Queue[+T] private(</span><br><span class="line">    private[this] var leading: List[T],</span><br><span class="line">    private[this] var traiting: List[T])&#123;</span><br><span class="line">  private def mirror() &#x3D;</span><br><span class="line">    if(leading.isEmpty) &#123;</span><br><span class="line">      while (!traiting.isEmpty)&#123;</span><br><span class="line">        leading &#x3D; traiting.head :: leading</span><br><span class="line">        traiting &#x3D; traiting.tail</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  def head: T &#x3D; &#123;</span><br><span class="line">    mirror()</span><br><span class="line">    leading.head</span><br><span class="line">  &#125;</span><br><span class="line">  def tail: Queue[T] &#x3D; &#123;</span><br><span class="line">    mirror()</span><br><span class="line">    new Queue(leading.tail, traiting)</span><br><span class="line">  &#125;</span><br><span class="line">  def append[U &gt;: T](x: U) &#x3D;</span><br><span class="line">  new Queue[U](leading, x :: traiting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合法变化型位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">abstract class Box[+A]&#123; def foo(): A &#125;</span><br><span class="line">abstract class Box[-A]&#123; def foo(a: A) &#125;</span><br><span class="line">abstract class Box[+A]&#123; def foo[B &gt;: A](b: B) &#125;</span><br><span class="line">abstract class Box[-A]&#123; def foo[B &lt;: A](): B&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="抽象成员"><a href="#抽象成员" class="headerlink" title="抽象成员"></a>抽象成员</h1><ul><li>scala 类可以是抽象的，特质本来就是抽象的，scala中的抽象类型是指某个类或者特质的成员<code>type T</code>，T作为类型的别名</li><li>如果没有赋初值或者实现，就是抽象val、var、def声明</li><li>抽象val限制了合法的实现，任何实现都必须是val类型的定义，而抽象方法则可以被实现为具体的方法或者具体的val定义</li><li>声明抽象的var，隐式声明了抽象getter和setter方法</li><li>特质的抽象val可以通过<code>new TraitName&#123; val n = 1+2&#125;</code>产生匿名类来初始化，但是初始化的值是在实例之后才能使用。可以通过预初始化字段和懒加载val解决</li><li>预初始化字段,字段在超类构造器之前被初始化，所以不能使用正被构造的对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new &#123;</span><br><span class="line">    val n &#x3D; 1 * x</span><br><span class="line">    val d &#x3D; 2 * x</span><br><span class="line">&#125; with TrainName</span><br></pre></td></tr></table></figure></li><li>lazy，对使用抽象变量的方法或者成员定义时 使用lazy<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val n: Int</span><br><span class="line">lazy val number &#x3D; n &#x2F; 10</span><br><span class="line">&#x2F;&#x2F;number将在n完成初始化之后才赋值</span><br></pre></td></tr></table></figure></li><li>抽象类型 <code>type T</code>是对声明点尚不可知的类型的引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Food</span><br><span class="line">abstract class Animal&#123;</span><br><span class="line">    type T &lt;: Food</span><br><span class="line">    def eat(food: T)</span><br><span class="line">&#125;</span><br><span class="line">class Grass extends Food</span><br><span class="line">class Cow extends Animal&#123;</span><br><span class="line">    type T &#x3D; Grass</span><br><span class="line">    overwride def eat(food: Grass)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>路径依赖类型-scala的类型可以作为对象的成员，路径依赖类型表达了外在的对象，内部类表达了外在的类<br>CurrencyZone#AbstractCurrency</li><li>scala.Enumeration</li><li>scala抽象类型，既不能创建抽象类型的实例，也不能把抽象类型当做其他类的超类型</li></ul><h1 id="隐式转换和隐式参数"><a href="#隐式转换和隐式参数" class="headerlink" title="隐式转换和隐式参数"></a>隐式转换和隐式参数</h1><ul><li>隐式转换：implict，可以在现存的类中添加新方法，所有的转换将自动包含新增加的方法；另外支持目标类型的转换。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implict def stringWrapper(s: String) &#x3D; </span><br><span class="line">    new RandomAccessSeq[Char]&#123;</span><br><span class="line">        def length &#x3D; s.length</span><br><span class="line">        def apply(i: Int) &#x3D; s.chartAt(i)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>隐式转换规则：<ul><li>标记规则：只有标记为implict的定义才是可用的</li><li>作用域规则：插入隐式转换必须以单一标识符的形式处于作用域中，或者转换的原或目标类型关联在一起</li><li>无歧义规则：隐式转换唯有不存在其他可插入转换的前提下才能插入</li><li>单一调用规则：只会尝试一个隐式操作</li><li>显示操作先行规则：若编写的代码类型检查无误，则不会尝试任何隐式操作</li><li>命名隐式转换：隐式转换可以任意命名。</li></ul></li><li>隐式操作的使用：转换为期望类型、指定（方法）调用者的转换、隐士隐式参数</li><li>隐式转换为期望类型是编译器使用隐式操作的第一个地方。</li><li>调用的方法不像是存在于接受者类中，就有可能使用隐式操作</li><li>隐式参数：参数列表中使用，添加缺失的参数列表以满足函数调用，implicit关键字应用于全体参数列表，而不是单独的参数</li></ul><p>隐式操作过于频繁使用，会让代码晦涩难懂，使用之前考虑是否可以用继承、混入组合或者方法重载代替</p><h1 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h1><ul><li>List是抽象类，不能通过new List构造器定义元素</li><li>类型参数T是协变的。</li><li>包含两个样本子类<code>::</code>和<code>Nil</code></li><li>Nill继承自List[Nothing],可以兼容任何类型的List</li></ul><h1 id="抽取器"><a href="#抽取器" class="headerlink" title="抽取器"></a>抽取器</h1><ul><li>scala里的抽取器是具有名为unapply成员方法的对象</li><li>抽取器推广模式匹配，可以定义模式类型，而不需要与选择的表达式类型相关联。</li></ul><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><ul><li>注解可以应用于方法、类的声明或定义、表达式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@deprecated</span><br><span class="line">@volatile &#x2F;&#x2F;通知编译器相关变量将被多个线程使用</span><br><span class="line">@serializable  &#x2F;&#x2F;标记是否可以序列化</span><br><span class="line">@SerialVersionUID(1234L)&#x2F;&#x2F;1234是版本号</span><br><span class="line">会转换成java字段定义</span><br><span class="line">private final static long SerialVersionUID &#x3D; 1234L</span><br><span class="line">@transient &#x2F;&#x2F;不进行序列化，对象被加载时根据类型恢复为默认值</span><br><span class="line">@scala.reflect.BeanProperty &#x2F;&#x2F;编译器自动产生get和set方法</span><br><span class="line">@unchecked &#x2F;&#x2F;编译器在模式匹配的时候解释，告诉编译器不要担心match表达式忽略了某些情况</span><br></pre></td></tr></table></figure></li></ul><h1 id="对象相等"><a href="#对象相等" class="headerlink" title="对象相等"></a>对象相等</h1><ul><li>对于引用类型，<code>==</code>在scala中相当于equals，不能被重写，equals可以</li><li>陷阱#1：错误的签名定义equals<br>重写时equals的参数必须是Any<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">overrde def equals(other: Any) &#x3D; other match &#123;</span><br><span class="line">    case that: Point &#x3D;&gt; this.x &#x3D;&#x3D; that.x &amp;&amp; this.y &#x3D;&#x3D; that.y &amp;&amp; this.getClass &#x3D;&#x3D; that.getClass</span><br><span class="line">    case _ &#x3D;&gt; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>陷阱#2：没有同时修改hashCode<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">override def hashCode &#x3D; 41 * (41 + x) + y</span><br></pre></td></tr></table></figure></li><li>陷阱#3：用可变字段定义equals<br>字段改变时，结果也会改变</li><li>陷阱#4：未能按等同关系定义equals方法<ul><li>它必须是自反射的：对于任何非空值x，表达式x.equals(x)应返回true</li><li>他是对称的：x.equals(y)和y.equals(x)的结果应该是一致的</li><li>可传递：x.equals(y)=true,y.equals(z)=true,则x.equals(z)=true</li><li>一致性：多次调用结果不会变</li><li>对于任何非空值x,x.equals(null)应该返回false</li></ul></li><li>scala并不检查抛出的异常是否被代码捕获，没有throws</li></ul><h1 id="Actor"><a href="#Actor" class="headerlink" title="Actor"></a>Actor</h1><ul><li>你必须推断出哪些是你正在修改或者访问的数据可能会被其他线程修改或者访问，只能通过推断解决。</li><li>actor不共享任何数据，以来消息传递的模型。是一类似线程的实体，有一个用来接收消息的邮箱。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import scala.actors._</span><br><span class="line">object SeriousActor extends Actor &#123;</span><br><span class="line">    def act() &#123;</span><br><span class="line">        for(i &lt;- 1 to 5)&#123;</span><br><span class="line">            println(&quot; to be or not to be&quot;)</span><br><span class="line">            Thread.sleep(1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">import scala.actors.Actor._</span><br><span class="line">val seriouseActor2 &#x3D; actor &#123;</span><br><span class="line">    for(i &lt;- 1 to 5)&#123;</span><br><span class="line">            println(&quot; to be or not to be&quot;)</span><br><span class="line">            Thread.sleep(1000)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:wuzhijunw@163.com">wufish</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://wufish.github.io/2018/11/29/bigdata/learningscala/">https://wufish.github.io/2018/11/29/bigdata/learningscala/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wufish.github.io" target="_blank">wufish的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/bigdata/">bigdata</a><a class="post-meta__tags" href="/tags/scala/">scala</a></div><div class="post_share"><div class="social-share" data-image="/images/default.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.png" target="_blank"><img class="post-qr-code-img" src="/images/wechat.png" alt="微信"></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2018/11/29/bigdata/hadoop&amp;hive%E5%8F%82%E6%95%B0/"><img class="prev-cover" src="/images/default.jpeg" onerror='onerror=null,src="/img/404.jpg"'><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">hadoop&amp;hive参数</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i> <span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2018/11/29/bigdata/learningMR/" title="学习记录-MR"><img class="cover" src="/images/default.jpeg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-29</div><div class="title">学习记录-MR</div></div></a></div><div><a href="/2018/11/29/bigdata/hadoop&hive参数/" title="hadoop&hive参数"><img class="cover" src="/images/default.jpeg"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-29</div><div class="title">hadoop&hive参数</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></article></main><footer id="footer" style="background-image:url(/images/default.jpeg)"><div id="footer-wrap"><div class="copyright">&copy;2020 By wufish</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49b1f5">hexo-generator-search</a> <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk({
      clientID: '233588b013801805cef1',
      clientSecret: 'cfe68da267d8ad8e1b430f8a616e5a0536562aad',
      repo: 'wufish.github.io',
      owner: 'wufish',
      admin: ['wufish'],
      id: '719e8df1b0e7c22a428f939ced8333af',
      language: 'zh-CN',
      perPage: 10,
      distractionFreeMode: false,
      pagerDirection: 'last',
      createIssueManually: false,
      updateCountCallback: commentCount
    })
    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    $.getScript('https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js', initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>